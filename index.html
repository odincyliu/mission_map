<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>è²“å’ªé—–é—œåœ°åœ–ï½œåŠ æ²¹!!</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="./assets/style.css">
</head>
<body>
  <div class="container py-4">
    <div class="d-flex align-items-center justify-content-between mb-3">
      <h1 class="app-title">ğŸ¾ è²“å’ªé—–é—œåœ°åœ– <span class="fs-5 text-muted">ï½œåŠ æ²¹!!</span></h1>
    </div>

    <div class="row g-4">
      <!-- ä»Šæ—¥ä»»å‹™ -->
      <div class="col-lg-5">
        <div class="card p-3">
          <div class="d-flex align-items-center mb-2">
            <span class="cat-badge me-2">ğŸ˜º</span>
            <h5 class="mb-0">ä»Šæ—¥ä»»å‹™</h5>
          </div>
          <div id="todayInfo" class="text-muted mb-3 small"></div>

          <div id="taskList" class="mb-2"></div>
          <div id="taskCounter" class="small text-muted mb-3"></div>

          <div class="input-group input-group-sm mb-2">
            <label class="input-group-text" for="taskCategory">æ–°å¢ä»»å‹™</label>
            <select id="taskCategory" class="form-select">
              <option value="ä½œæ¥­">ä½œæ¥­</option>
              <option value="è¤‡ç¿’">è¤‡ç¿’</option>
              <option value="æ•´ç†æ›¸åŒ…">æ•´ç†æ›¸åŒ…</option>
              <option value="é–±è®€">é–±è®€</option>
              <option value="å‡±çˆº">å‡±çˆº</option>
              <option value="å…¶ä»–">å…¶ä»–</option>
            </select>
            <input id="taskDetail" type="text" class="form-control" placeholder="è¼¸å…¥è©³ç´°å…§å®¹ï¼Œä¾‹å¦‚ï¼šåœ‹ç¿’3" />
            <button id="btnAddTask" class="btn btn-outline-secondary">â•</button>
          </div>
          <div class="input-group input-group-sm mb-1">
            <label class="input-group-text" for="rewardType">çå‹µ</label>
            <select id="rewardType" class="form-select">
              <option value="points">é»æ•¸</option>
              <option value="custom">è‡ªè¨‚</option>
              <option value="preset:ç©æ’²å…‹ç‰Œä¸€æ¬¡">ç©æ’²å…‹ç‰Œä¸€æ¬¡</option>
              <option value="preset:æŒè²é¼“å‹µ">æŒè²é¼“å‹µ</option>
              <option value="preset:ä¼‘æ¯10åˆ†é˜">ä¼‘æ¯10åˆ†é˜</option>
              <option value="preset:äº”éš»è²“">äº”éš»è²“</option>
            </select>
            <input id="rewardPoints" type="number" class="form-control" min="0" value="1" placeholder="è¼¸å…¥é»æ•¸" />
            <input id="rewardCustom" type="text" class="form-control d-none" placeholder="è¼¸å…¥çå‹µå…§å®¹ï¼Œä¾‹å¦‚ï¼šç© 10 åˆ†é˜ Switch" />
          </div>
          <div class="form-text small text-muted mb-3">å¯é¸æ“‡é»æ•¸æˆ–è¼¸å…¥å…¶ä»–çå‹µå…§å®¹ã€‚</div>
          <div class="small text-muted mb-3">å®Œæˆä»Šæ—¥ä»»å‹™å¾Œæœƒè‡ªå‹•è“‹ç« ä¸¦æ”¶é›†è²¼ç´™ã€‚</div>

          <div id="msg" class="mt-3"></div>

          <hr>
          <ul class="rule-list small mb-0">
            <li>å®Œæˆ <b>ç•¶æ—¥ä»»å‹™</b> å¾Œï¼Œç³»çµ±æœƒè‡ªå‹•è“‹ç« ä¸¦æ”¶é›†è²¼ç´™ã€‚</li>
            <li>é—–é—œç´€éŒ„æœƒä¾ç…§ Google è¡¨å–®è³‡æ–™è‡ªå‹•æ›´æ–°ä¸¦çµ±è¨ˆçå‹µã€‚</li>
            <li>æ¯é€±ä¸€æœƒè‡ªå‹•å»ºç«‹æ–°åœ°åœ–ä¸¦ä¿ç•™æ­·å²é€±ç´€éŒ„ã€‚</li>
          </ul>
        </div>
      </div>

      <!-- åœ°åœ–å€ -->
      <div class="col-lg-7">
        <div class="card p-3">
          <div class="d-flex align-items-center mb-2">
            <span class="cat-badge me-2">ğŸ¾</span>
            <h5 class="mb-0">æœ¬é€±é—–é—œåœ°åœ–</h5>
          </div>
          <div id="weekInfo" class="text-muted small mb-3"></div>

          <div class="mb-3">
            <label for="weekPicker" class="form-label small text-muted mb-1">é¸æ“‡æ—¥æœŸ</label>
            <input id="weekPicker" type="date" class="form-control form-control-sm" aria-describedby="weekPickerHelp" />
            <div id="weekPickerHelp" class="form-text small text-muted">æŒ‘é¸ä»»ä¸€æ—¥æœŸå³å¯åˆ‡æ›è‡³è©²é€±ç´€éŒ„ã€‚</div>
          </div>

          <div class="map-wrap position-relative">
            <div class="row row-cols-2 row-cols-sm-4 row-cols-md-7 g-3" id="mapRow"></div>
          </div>

          <div class="mt-4">
            <div class="d-flex align-items-center mb-2">
              <span class="cat-badge me-2">ğŸ</span>
              <h6 class="mb-0">æœ¬é€±è²¼ç´™æ”¶è—</h6>
            </div>
            <div class="row g-2" id="stickerRow"></div>
          </div>

          <div class="mt-4">
            <div class="d-flex align-items-center mb-2">
              <span class="cat-badge me-2">ğŸ’</span>
              <h6 class="mb-0">çå‹µç´€éŒ„</h6>
            </div>
            <div class="row g-2 small" id="rewardSummary">
              <div class="col-12 col-md-6">
                <div class="reward-panel h-100" id="rewardToday"></div>
              </div>
              <div class="col-12 col-md-6">
                <div class="reward-panel h-100" id="rewardWeek"></div>
              </div>
            </div>
          </div>

      </div>
    </div>

  </div>

    <footer class="text-center text-muted small mt-4">
      ç”±å®¶é•·èˆ‡å­©å­ä¸€èµ·ä½¿ç”¨ï¼šå®Œæˆä»»å‹™ â†’ ç³»çµ±è‡ªå‹•åˆ¤å®šé—–é—œæˆåŠŸ â†’ æ”¶é›†å°è²“è²¼ç´™ã€‚
    </footer>
  </div>

  <div id="loadingOverlay" class="loading-overlay" role="status" aria-hidden="true">
    <div class="loading-box text-center">
      <div class="spinner-border text-warning" role="status" aria-hidden="true"></div>
      <div class="fw-semibold">è³‡æ–™è™•ç†ä¸­â€¦</div>
      <div class="small text-muted">è«‹ç¨å€™ï¼Œæ­£åœ¨èˆ‡é›²ç«¯åŒæ­¥</div>
    </div>
  </div>

  <script>
    // === å·¥å…· ===
    const DEFAULT_STICKER_ALT = 'å¡é€šè²“è²¼ç´™';
    const CAT_SPRITE_ROWS = 10;
    const CAT_SPRITE_COLS = 10;
    const CAT_SPRITE_PATH = './assets/Gemini_Generated_Image_5udqzj5udqzj5udq.png';
    const STICKER_HISTORY_KEY = 'catmap:spriteHistory';
    const STICKER_UNIQUE_DAYS = 30;

    // å–å¾—ç•¶åœ°æ™‚é–“ï¼ˆä»¥ä½¿ç”¨è€…ç€è¦½å™¨ç‚ºæº–ï¼‰
    function todayYMD(){
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
    function weekStart(d){ // ä»¥é€±ä¸€ç‚ºä¸€é€±èµ·å§‹
      const x = new Date(d);
      const day = x.getDay(); // 0(æ—¥)-6(å…­)
      const diff = (day===0? -6 : 1) - day; // è½‰åˆ°é€±ä¸€
      x.setDate(x.getDate()+diff);
      x.setHours(0,0,0,0);
      return x;
    }
    function fmtDate(d){
      return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }

function ensureCatSpriteStyles(){
      if(document.getElementById('catSpriteStyles')){
        return;
      }
      const style = document.createElement('style');
      style.id = 'catSpriteStyles';

      // ==========================================
      // ğŸ”§ é—œéµä¿®æ­£ï¼šç¸®æ”¾ä¿‚æ•¸ (Scale Factor)
      // 1.25 ä»£è¡¨æ”¾å¤§ 25%ã€‚
      // åŸç†ï¼šæ”¾å¤§å¾Œï¼Œæ ¼å­é‚Šç·£åŸæœ¬æœƒã€Œç©¿å¹«ã€çš„éƒ¨åˆ†ï¼ˆåˆ¥äººçš„è…³ï¼‰æœƒè¢«æ“ å‡ºè¦–çª—å¤–ã€‚
      // å¦‚æœè¦ºå¾—è²“å’ªè¢«åˆ‡æ‰å¤ªå¤šï¼Œå¯ä»¥è©¦è‘—æ”¹ç‚º 1.15 æˆ– 1.2
      // ==========================================
      const SCALE = 1.25; 

      const cols = CAT_SPRITE_COLS;
      const rows = CAT_SPRITE_ROWS;

      // è¨ˆç®—ç¶“éç¸®æ”¾å¾Œçš„ã€Œåˆ†æ¯ã€
      // é€™æ˜¯ç‚ºäº†ç¢ºä¿æ”¾å¤§å¾Œï¼Œåœ–ç‰‡ä¾ç„¶èƒ½å¤ æº–ç¢ºå°é½Šä¸­å¿ƒé»
      const denomX = cols * SCALE - 1;
      const denomY = rows * SCALE - 1;

      // è¨ˆç®—æ¯ä¸€æ­¥çš„ç™¾åˆ†æ¯” (Step)
      const stepX = denomX > 0 ? (SCALE / denomX) * 100 : 0;
      const stepY = denomY > 0 ? (SCALE / denomY) * 100 : 0;

      // è¨ˆç®—èµ·å§‹åç§»é‡ (Offset)
      // ç”¨ä¾†ä¿®æ­£æ”¾å¤§å¾Œé€ æˆçš„ä¸­å¿ƒé»åç§»
      const offX = denomX > 0 ? (0.5 * (SCALE - 1) / denomX) * 100 : 0;
      const offY = denomY > 0 ? (0.5 * (SCALE - 1) / denomY) * 100 : 0;

      // èƒŒæ™¯åœ–å°ºå¯¸ä¹Ÿè¦ä¹˜ä¸Šç¸®æ”¾å€ç‡
      const bgWidth = `${cols * 100 * SCALE}%`;
      const bgHeight = `${rows * 100 * SCALE}%`;

      let css = `.cat-sprite{width:100%;height:100%;background-image:url('${CAT_SPRITE_PATH}');background-size:${bgWidth} ${bgHeight};background-repeat:no-repeat;border-radius:.5rem;}`;

      for(let row=1; row<=rows; row++){
        for(let col=1; col<=cols; col++){
          // å…¬å¼ï¼šåç§»é‡ + (ç´¢å¼• * æ­¥é•·)
          const posX = offX + stepX * (col - 1);
          const posY = offY + stepY * (row - 1);
          css += `.cat-${row}-${col}{background-position:${posX}% ${posY}%;}`;
        }
      }
      
      style.textContent = css;
      document.head.appendChild(style);
}

    function spriteKey(row, col){
      return `${row}-${col}`;
    }

    function normalizeSpriteCoords(row, col){
      const r = Number(row);
      const c = Number(col);
      if(Number.isInteger(r) && Number.isInteger(c) && r>=1 && r<=CAT_SPRITE_ROWS && c>=1 && c<=CAT_SPRITE_COLS){
        return {row:r, col:c, key:spriteKey(r, c)};
      }
      return null;
    }

    function parseSpriteKey(key){
      if(typeof key !== 'string') return null;
      const match = key.trim().match(/^(\d+)-(\d+)$/);
      if(!match) return null;
      return normalizeSpriteCoords(Number(match[1]), Number(match[2]));
    }

    function loadSpriteHistory(){
      const data = loadJSON(STICKER_HISTORY_KEY, []);
      return Array.isArray(data) ? data : [];
    }

    function pruneSpriteHistory(history){
      const cutoff = new Date();
      cutoff.setDate(cutoff.getDate() - STICKER_UNIQUE_DAYS);
      const cutoffStr = fmtDate(cutoff);
      const trimmed = (Array.isArray(history) ? history : []).filter(entry=>{
        return entry && entry.key && entry.date && String(entry.date) >= cutoffStr;
      });
      saveJSON(STICKER_HISTORY_KEY, trimmed);
      return trimmed;
    }

    function getAllSpriteKeys(){
      const keys = [];
      for(let r=1; r<=CAT_SPRITE_ROWS; r++){
        for(let c=1; c<=CAT_SPRITE_COLS; c++){
          keys.push(spriteKey(r,c));
        }
      }
      return keys;
    }

    function rememberSpriteUsage(key, dateStr){
      const history = pruneSpriteHistory(loadSpriteHistory());
      const record = {key, date: dateStr || todayYMD()};
      history.push(record);
      saveJSON(STICKER_HISTORY_KEY, history);
    }

    function getUniqueCatSticker(dateStr){
      ensureCatSpriteStyles();
      const history = pruneSpriteHistory(loadSpriteHistory());
      const used = new Set(history.map(item=>item && item.key).filter(Boolean));
      const allKeys = getAllSpriteKeys();
      const available = allKeys.filter(k=>!used.has(k));
      const pickList = available.length ? available : allKeys;
      const chosenKey = pickList[Math.floor(Math.random()*pickList.length)];
      const coords = parseSpriteKey(chosenKey);
      if(coords){
        rememberSpriteUsage(coords.key, dateStr);
        return {type:'sprite', row: coords.row, col: coords.col, key: coords.key};
      }
      return {type:'emoji', value:'ğŸ¾'};
    }

    function normalizeSticker(raw){
      if(!raw){
        return null;
      }
      const spriteFromCoords = (row,col)=>{
        const coords = normalizeSpriteCoords(row, col);
        if(!coords){ return null; }
        return {type:'sprite', row: coords.row, col: coords.col, key: coords.key};
      };
      if(typeof raw === 'string'){
        const trimmed = raw.trim();
        if(!trimmed){
          return null;
        }
        const spriteMatch = trimmed.match(/^cat-(\d+)-(\d+)$/i);
        if(spriteMatch){
          return spriteFromCoords(Number(spriteMatch[1]), Number(spriteMatch[2]));
        }
        if(/^https?:\/\//i.test(trimmed)){
          return {type:'image', url: trimmed, alt: DEFAULT_STICKER_ALT};
        }
        return {type:'emoji', value: trimmed};
      }
      if(typeof raw === 'object'){
        if(raw.type === 'sprite'){
          const coords = spriteFromCoords(raw.row ?? raw.r ?? raw.x, raw.col ?? raw.c ?? raw.y);
          if(coords){ return coords; }
          if(raw.key){
            const parsed = parseSpriteKey(raw.key);
            if(parsed){ return {type:'sprite', row: parsed.row, col: parsed.col, key: parsed.key}; }
          }
        }
        const type = raw.type;
        if(type === 'image'){
          const url = raw.url || raw.value || '';
          if(url){
            return {type:'image', url: String(url), alt: raw.alt ? String(raw.alt) : DEFAULT_STICKER_ALT};
          }
        }
        if(type === 'emoji'){
          const value = raw.value || raw.emoji || '';
          if(value){
            return {type:'emoji', value: String(value)};
          }
        }
        if(raw.url){
          return {type:'image', url: String(raw.url), alt: raw.alt ? String(raw.alt) : DEFAULT_STICKER_ALT};
        }
        if(raw.value){
          const value = String(raw.value).trim();
          if(!value){
            return null;
          }
          if(/^https?:\/\//i.test(value)){
            return {type:'image', url: value, alt: raw.alt ? String(raw.alt) : DEFAULT_STICKER_ALT};
          }
          return {type:'emoji', value};
        }
      }
      return null;
    }

    function isStickerFilled(sticker){
      if(!sticker){ return false; }
      if(typeof sticker === 'object'){
        if(sticker.type === 'sprite'){
          const coords = normalizeSpriteCoords(sticker.row, sticker.col);
          return !!coords;
        }
        if(sticker.type === 'image'){
          return !!sticker.url;
        }
        if(sticker.type === 'emoji'){
          return !!sticker.value;
        }
        return false;
      }
      if(typeof sticker === 'string'){
        return sticker.trim().length > 0;
      }
      return false;
    }

    function getStickerTitle(sticker){
      if(sticker && typeof sticker === 'object'){
        if(sticker.type === 'sprite'){
          const coords = normalizeSpriteCoords(sticker.row, sticker.col);
          if(coords){
            return `è²“å’ªè²¼ç´™ ${coords.row}-${coords.col}`;
          }
          return DEFAULT_STICKER_ALT;
        }
        if(sticker.type === 'image'){
          const alt = sticker.alt || DEFAULT_STICKER_ALT;
          const firstTag = alt.split(',')[0].trim();
          return firstTag || DEFAULT_STICKER_ALT;
        }
        if(sticker.type === 'emoji'){
          return sticker.value || DEFAULT_STICKER_ALT;
        }
      }
      if(typeof sticker === 'string' && sticker.trim()){
        return sticker.trim();
      }
      return DEFAULT_STICKER_ALT;
    }

    function createStickerContent(sticker){
      if(sticker && typeof sticker === 'object'){
        if(sticker.type === 'sprite' && (sticker.row || sticker.col)){
          const coords = normalizeSpriteCoords(sticker.row, sticker.col);
          if(coords){
            ensureCatSpriteStyles();
            const div = document.createElement('div');
            div.className = `cat-sprite cat-${coords.row}-${coords.col}`;
            div.role = 'img';
            div.setAttribute('aria-label', getStickerTitle(sticker));
            return div;
          }
        }
        if(sticker.type === 'image' && sticker.url){
          const img = document.createElement('img');
          img.src = sticker.url;
          img.alt = sticker.alt || DEFAULT_STICKER_ALT;
          img.className = 'sticker-img';
          return img;
        }
        if(sticker.type === 'emoji' && sticker.value){
          const span = document.createElement('span');
          span.className = 'bigcat';
          span.textContent = sticker.value;
          return span;
        }
      }
      if(typeof sticker === 'string' && sticker.trim()){
        const span = document.createElement('span');
        span.className = 'bigcat';
        span.textContent = sticker.trim();
        return span;
      }
      const span = document.createElement('span');
      span.className = 'bigcat';
      span.textContent = 'ğŸ”²';
      return span;
    }

    function normalizeApiDate(raw){
      if(raw instanceof Date && !Number.isNaN(raw.getTime())){
        return fmtDate(raw);
      }
      if(typeof raw === 'number' && Number.isFinite(raw)){
        const d = new Date(raw);
        if(!Number.isNaN(d.getTime())){
          return fmtDate(d);
        }
      }
      if(typeof raw === 'string'){
        const trimmed = raw.trim();
        if(!trimmed){ return ''; }
        const parsed = Date.parse(trimmed.replace(/[å¹´]/g, '/').replace(/[æœˆ]/g, '/').replace(/[æ—¥]/g, ''));
        if(!Number.isNaN(parsed)){
          const d = new Date(parsed);
          if(!Number.isNaN(d.getTime())){
            return fmtDate(d);
          }
        }
        const match = trimmed.match(/^(\d{4})[\/-å¹´](\d{1,2})[\/-æœˆ](\d{1,2})/);
        if(match){
          const y = Number(match[1]);
          const m = Number(match[2]);
          const day = Number(match[3]);
          if(Number.isFinite(y) && Number.isFinite(m) && Number.isFinite(day)){
            const d = new Date(y, m-1, day);
            if(!Number.isNaN(d.getTime())){
              return fmtDate(d);
            }
          }
        }
      }
      return '';
    }

    // LocalStorage Key ä»¥é€±ä¸€æ—¥æœŸå‘½å
    function storageKey(prefix, date){
      let base = date instanceof Date ? new Date(date) : new Date(date || Date.now());
      if(Number.isNaN(base.getTime())){
        base = new Date();
      }
      const ws = weekStart(base);
      return `${prefix}:${fmtDate(ws)}`;
    }

    function loadJSON(key, fallback){
      try{ return JSON.parse(localStorage.getItem(key)) ?? fallback; }catch(e){ return fallback; }
    }
    function saveJSON(key, obj){
      localStorage.setItem(key, JSON.stringify(obj));
    }

    // === ç‹€æ…‹ ===
    const WEEK_DAYS = ["é€±ä¸€","é€±äºŒ","é€±ä¸‰","é€±å››","é€±äº”","é€±å…­","é€±æ—¥"];

    const initialWeekStart = weekStart(new Date());
    const state = {
      weekKey: storageKey('catmap', initialWeekStart),
      currentWeekStart: fmtDate(initialWeekStart),
      weekData: null,
      today: todayYMD(),
      selectedDate: null,
      loadingDate: null,
      isLoadingDay: false,
    };

    let globalLoadingCounter = 0;

    function updateGlobalLoadingOverlay(){
      const overlay = document.getElementById('loadingOverlay');
      const isActive = globalLoadingCounter > 0;
      if(overlay){
        overlay.classList.toggle('show', isActive);
        overlay.setAttribute('aria-hidden', isActive ? 'false' : 'true');
      }
      if(document.body){
        document.body.classList.toggle('loading-active', isActive);
        document.body.setAttribute('aria-busy', isActive ? 'true' : 'false');
      }
    }

    function pushGlobalLoading(){
      globalLoadingCounter += 1;
      updateGlobalLoadingOverlay();
    }

    function popGlobalLoading(){
      globalLoadingCounter = Math.max(0, globalLoadingCounter - 1);
      updateGlobalLoadingOverlay();
    }

    async function withGlobalLoading(task){
      pushGlobalLoading();
      try{
        return await (typeof task === 'function' ? task() : task);
      }finally{
        popGlobalLoading();
      }
    }

    function uid(){
      if(window.crypto && window.crypto.randomUUID){
        return window.crypto.randomUUID();
      }
      return 't' + Math.random().toString(36).slice(2,9);
    }

    function defaultReward(){
      return {type:'points', value:10};
    }

    function markTaskSource(task, source){
      if(!task.source){ task.source = source; }
      return task;
    }

    function parseDoneFlag(value){
      if(typeof value === 'boolean'){ return value; }
      if(typeof value === 'number'){ return value !== 0; }
      if(typeof value === 'string'){
        const text = value.replace(/[\s\uFEFF]+$/u, '').trim();
        if(!text){ return false; }
        if(/^[âœ“âœ”âœ…]$/.test(text)){ return true; }
        if(text === 'æ˜¯' || text === 'å·²å®Œæˆ' || text === 'å®Œæˆ'){ return true; }
        if(text === 'å¦' || text === 'æœªå®Œæˆ'){ return false; }
        const lowered = text.toLowerCase();
        if(['true','1','y','yes','ok','done','å®Œæˆ'].includes(lowered)){ return true; }
        if(['false','0','n','no','pending'].includes(lowered)){ return false; }
      }
      return false;
    }

    function formatDoneFlag(value){
      return value ? 'æ˜¯' : 'å¦';
    }

    function defaultTasks(){
      return [];
    }

    function createDefaultWeekData(weekStartInput){
      const base = weekStart(weekStartInput instanceof Date ? weekStartInput : new Date(weekStartInput || Date.now()));
      const wsStr = fmtDate(base);
      const days = Array.from({length:7}, (_,i)=>{
        const dayDate = new Date(base);
        dayDate.setDate(base.getDate()+i);
        return {
          date: fmtDate(dayDate),
          tasks: defaultTasks(),
          passed: false,
          sticker: null
        };
      });
      return {weekStart: wsStr, days};
    }

    function generateApiId(){
      const used = new Set();
      if(state.weekData && Array.isArray(state.weekData.days)){
        state.weekData.days.forEach(day=>{
          if(day && Array.isArray(day.tasks)){
            day.tasks.forEach(task=>{ if(task && task.id){ used.add(String(task.id)); } });
          }
        });
      }
      let id = '';
      let guard = 0;
      while(!id || used.has(id)){
        const timePart = Date.now().toString();
        const randomPart = Math.floor(Math.random()*1000).toString().padStart(3,'0');
        id = `${timePart}${randomPart}`;
        guard += 1;
        if(guard > 5){ id = `${timePart}${Math.floor(Math.random()*1e6).toString().padStart(6,'0')}`; }
      }
      return id;
    }

    function rewardFromApi(raw){
      if(raw === undefined || raw === null || raw === ''){
        return defaultReward();
      }
      if(typeof raw === 'object' && !Array.isArray(raw)){
        const holder = {reward: raw};
        ensureTaskReward(holder);
        return holder.reward;
      }
      if(typeof raw === 'number'){
        return {type:'points', value: Math.max(0, Math.round(raw))};
      }
      if(typeof raw === 'string'){
        try{
          const obj = JSON.parse(raw);
          if(obj && typeof obj === 'object'){
            const holder = {reward: obj};
            ensureTaskReward(holder);
            return holder.reward;
          }
        }catch(e){
          // ignore JSON parse error
        }
        const num = Number(raw);
        if(Number.isFinite(num)){
          return {type:'points', value: Math.max(0, Math.round(num))};
        }
        const text = raw.trim();
        if(!text){
          return defaultReward();
        }
        if(text.startsWith('custom:')){
          return {type:'custom', value:text.slice(7)};
        }
        if(text.startsWith('points:')){
          const val = Number(text.slice(7));
          if(Number.isFinite(val)){
            return {type:'points', value: Math.max(0, Math.round(val))};
          }
        }
        return {type:'custom', value:text};
      }
      return defaultReward();
    }

    function parseTaskFromApi(record){
      if(!record) return null;
      const rawId = record.id ?? record.ID ?? record.Id;
      const task = {
        id: String(rawId ?? generateApiId()),
        category: 'å…¶ä»–',
        detail: '',
        done: false,
        reward: defaultReward(),
        source: 'api'
      };
      const rawItem = record.item ?? record.Item ?? record['é …ç›®'];
      if(rawItem){
        if(typeof rawItem === 'string'){
          try{
            const obj = JSON.parse(rawItem);
            if(obj && typeof obj === 'object'){
              if(obj.category){ task.category = String(obj.category); }
              if(obj.detail){ task.detail = String(obj.detail); }
            }else{
              const parts = rawItem.split('ï½œ');
              if(parts.length > 1){
                task.category = parts[0] || task.category;
                task.detail = parts.slice(1).join('ï½œ');
              }else{
                task.detail = rawItem;
              }
            }
          }catch(e){
            const parts = rawItem.split('ï½œ');
            if(parts.length > 1){
              task.category = parts[0] || task.category;
              task.detail = parts.slice(1).join('ï½œ');
            }else{
              task.detail = rawItem;
            }
          }
        }else if(typeof rawItem === 'object'){
          if(rawItem.category){ task.category = String(rawItem.category); }
          if(rawItem.detail){ task.detail = String(rawItem.detail); }
        }
      }
      const rawReward = record.reward ?? record.Reward ?? record['çå‹µ'];
      task.reward = rewardFromApi(rawReward);
      ensureTaskReward(task);
      const doneKeys = ['done','Done','DONE','å®Œæˆ ','å®Œæˆ','å·²å®Œæˆ','isDone','status'];
      const hasDoneField = doneKeys.some(key=>Object.prototype.hasOwnProperty.call(record, key));
      const doneField = record.done ?? record.Done ?? record.DONE ?? record['å®Œæˆ '] ?? record['å®Œæˆ'] ?? record['å·²å®Œæˆ'] ?? record['isDone'] ?? record['status'];
      task.done = parseDoneFlag(doneField);
      task._hasRemoteDone = hasDoneField;
      return task;
    }

    function encodeTaskForApi({id, category, detail, reward, done}, date){
      return {
        id: String(id),
        date,
        item: JSON.stringify({category, detail}),
        reward: JSON.stringify(reward),
        done: formatDoneFlag(!!done)
      };
    }

    function ensureTaskReward(task){
      if(!task.reward || typeof task.reward !== 'object'){
        task.reward = defaultReward();
      }
      const r = task.reward;
      if(r.type === 'custom'){
        task.reward = {type:'custom', value: String(r.value ?? '').trim()};
      }else if(r.type === 'points'){
        const num = Number(r.value);
        const safe = Number.isFinite(num) ? Math.max(0, Math.round(num)) : 0;
        task.reward = {type:'points', value: safe};
      }else{
        const fallback = Number(r.value);
        const safe = Number.isFinite(fallback) ? Math.max(0, Math.round(fallback)) : 0;
        task.reward = {type:'points', value: safe};
      }
      return task.reward;
    }

    function refreshDayStatus(day, {silent=true}={}){
      if(!day){
        return {total:0, doneCount:0, completed:false};
      }
      ensureDayStructure(day);
      const total = Array.isArray(day.tasks) ? day.tasks.length : 0;
      let doneCount = 0;
      if(Array.isArray(day.tasks)){
        day.tasks.forEach(task=>{ if(task && task.done){ doneCount += 1; } });
      }
      const completed = total > 0 && doneCount === total;
      const prev = !!day.passed;
      day.passed = completed;
      day.sticker = normalizeSticker(day.sticker);
      if(completed){
        if(!isStickerFilled(day.sticker)){
          day.sticker = getUniqueCatSticker(day.date);
        }
      }else if(isStickerFilled(day.sticker)){
        day.sticker = null;
      }
      if(!silent && completed !== prev){
        if(completed){
          toastMsg('ä»Šæ—¥ä»»å‹™å·²å®Œæˆï¼å¾—åˆ°å¡é€šè²“è²¼ç´™ï¼', 'success');
        }else{
          toastMsg('å·²å–æ¶ˆä»Šæ—¥é—–é—œæˆåŠŸã€‚', 'info');
        }
      }
      return {total, doneCount, completed};
    }

    function getTaskRewardLabel(task){
      const reward = ensureTaskReward(task);
      if(reward.type === 'custom'){
        return reward.value || 'æœªè¨­å®š';
      }
      return `${reward.value || 0} é»`;
    }

    function collectRewardsFromDay(day){
      const summary = {points:0, custom:[], doneCount:0};
      if(!day || !Array.isArray(day.tasks)) return summary;
      day.tasks.forEach(task=>{
        ensureTaskReward(task);
        if(!task.done) return;
        summary.doneCount += 1;
        if(task.reward.type === 'points'){
          summary.points += Number(task.reward.value) || 0;
        }else if(task.reward.type === 'custom'){
          const text = (task.reward.value || '').trim();
          if(text){ summary.custom.push(text); }
        }
      });
      return summary;
    }

    function updateRewardSummary(){
      const todayBox = document.getElementById('rewardToday');
      const weekBox = document.getElementById('rewardWeek');
      if(!todayBox || !weekBox || !state.weekData || !Array.isArray(state.weekData.days)) return;
      const {day: selectedDay} = ensureSelectedDay();
      if(selectedDay){ ensureDayStructure(selectedDay); }

      const isLoadingSelected = state.isLoadingDay && selectedDay && state.loadingDate === selectedDay.date;
      const selectedSummary = collectRewardsFromDay(selectedDay);
      const heading = selectedDay
        ? (selectedDay.date === state.today ? 'ä»Šæ—¥çå‹µ' : `æ‰€é¸æ—¥æœŸï¼ˆ${selectedDay.date}ï¼‰çå‹µ`)
        : 'æ‰€é¸æ—¥æœŸçå‹µ';
      const todayParts = [`<div class="fw-bold mb-1">${heading}</div>`];
      if(!selectedDay){
        todayParts.push('<div class="text-muted">å°šæœªé¸æ“‡ä»»å‹™æ—¥ã€‚</div>');
      }else if(isLoadingSelected){
        todayParts.push('<div class="text-muted">ä»»å‹™è¼‰å…¥ä¸­â€¦</div>');
      }else if(!selectedSummary.doneCount){
        todayParts.push('<div class="text-muted">å°šæœªå®Œæˆä»»å‹™ã€‚</div>');
      }else{
        todayParts.push(`<div class="mb-1">é»æ•¸ï¼š<strong>${selectedSummary.points}</strong> é»</div>`);
        if(selectedSummary.custom.length){
          todayParts.push('<div>å…¶ä»–çå‹µï¼š</div>');
          todayParts.push(`<ul class="reward-list mb-0">${selectedSummary.custom.map(item=>`<li>${item}</li>`).join('')}</ul>`);
        }else{
          todayParts.push('<div class="text-muted">ç„¡å…¶ä»–çå‹µè¨˜éŒ„ã€‚</div>');
        }
      }
      todayBox.innerHTML = todayParts.join('');

      let weekPoints = 0;
      const weekCustom = [];
      let weekHasAny = false;
      state.weekData.days.forEach((d, i)=>{
        ensureDayStructure(d);
        const summary = collectRewardsFromDay(d);
        if(summary.doneCount){ weekHasAny = true; }
        weekPoints += summary.points;
        if(summary.custom.length){
          summary.custom.forEach(text=>weekCustom.push(`${WEEK_DAYS[i]}ï¼š${text}`));
        }
      });

      const weekParts = ['<div class="fw-bold mb-1">æœ¬é€±ç´¯ç©</div>'];
      if(!weekHasAny && weekPoints === 0 && weekCustom.length === 0){
        weekParts.push('<div class="text-muted">å°šæœªç´¯ç©çå‹µã€‚</div>');
      }else{
        weekParts.push(`<div class="mb-1">é»æ•¸ï¼š<strong>${weekPoints}</strong> é»</div>`);
        if(weekCustom.length){
          weekParts.push('<div>å…¶ä»–çå‹µï¼š</div>');
          weekParts.push(`<ul class="reward-list mb-0">${weekCustom.map(item=>`<li>${item}</li>`).join('')}</ul>`);
        }else{
          weekParts.push('<div class="text-muted">ç„¡å…¶ä»–çå‹µè¨˜éŒ„ã€‚</div>');
        }
      }
      weekBox.innerHTML = weekParts.join('');
    }

    function ensureDayStructure(day){
      if(!day.tasks){
        day.tasks = defaultTasks();
      }else if(!Array.isArray(day.tasks)){
        const obj = day.tasks;
        const arr = [];
        if(Object.prototype.hasOwnProperty.call(obj, 'hw')){
          arr.push(markTaskSource({id:uid(), category:'ä½œæ¥­', detail:'', done:!!obj.hw, reward:defaultReward()}, 'local'));
        }
        if(Object.prototype.hasOwnProperty.call(obj, 'review')){
          arr.push(markTaskSource({id:uid(), category:'è¤‡ç¿’', detail:'', done:!!obj.review, reward:defaultReward()}, 'local'));
        }
        if(Object.prototype.hasOwnProperty.call(obj, 'bag')){
          arr.push(markTaskSource({id:uid(), category:'æ•´ç†æ›¸åŒ…', detail:'', done:!!obj.bag, reward:defaultReward()}, 'local'));
        }
        day.tasks = arr.length ? arr : defaultTasks();
      }
      if(typeof day.passed !== 'boolean'){ day.passed = !!day.passed; }
      day.sticker = normalizeSticker(day.sticker);
      day.tasks.forEach(task=>{
        ensureTaskReward(task);
        if(!task.id){ task.id = uid(); }
        markTaskSource(task, 'local');
      });
    }

    function loadWeekForDate(dateStr, {sync=true}={}){
      let baseDate = null;
      if(dateStr instanceof Date && !Number.isNaN(dateStr.getTime())){
        baseDate = new Date(dateStr);
      }else{
        const normalized = normalizeApiDate(dateStr || '');
        if(normalized){
          const parsed = new Date(normalized);
          if(!Number.isNaN(parsed.getTime())){
            baseDate = parsed;
          }
        }
      }
      if(!baseDate){
        baseDate = new Date();
      }
      baseDate.setHours(0,0,0,0);

      const ws = weekStart(baseDate);
      const wsStr = fmtDate(ws);
      state.currentWeekStart = wsStr;
      state.weekKey = storageKey('catmap', ws);

      const fallbackWeek = createDefaultWeekData(ws);
      const weekChanged = !state.weekData || state.weekData.weekStart !== wsStr;
      if(weekChanged){
        let weekData = loadJSON(state.weekKey, fallbackWeek);
        if(!weekData || weekData.weekStart !== wsStr || !Array.isArray(weekData.days) || weekData.days.length !== 7){
          weekData = fallbackWeek;
        }
        state.weekData = weekData;
      }

      if(!state.weekData){
        state.weekData = fallbackWeek;
      }
      if(state.weekData.weekStart !== wsStr){
        state.weekData.weekStart = wsStr;
      }
      if(!Array.isArray(state.weekData.days) || state.weekData.days.length !== 7){
        state.weekData.days = fallbackWeek.days.slice();
      }

      state.weekData.days.forEach((day, idx)=>{
        if(!day || typeof day !== 'object'){
          state.weekData.days[idx] = fallbackWeek.days[idx];
          day = state.weekData.days[idx];
        }else if(!day.date){
          day.date = fallbackWeek.days[idx].date;
        }
        ensureDayStructure(day);
        refreshDayStatus(day, {silent:true});
      });

      const normalizedSelected = fmtDate(baseDate);
      const hasSelected = state.weekData.days.some(d=>d.date === normalizedSelected);
      state.selectedDate = hasSelected ? normalizedSelected : (state.weekData.days[0]?.date || null);
      state.loadingDate = null;
      state.isLoadingDay = false;
      ensureSelectedDay();
      render();
      saveJSON(state.weekKey, state.weekData);
      if(sync){
        syncWeekFromApi();
      }
      return {weekChanged, selectedDate: state.selectedDate};
    }

    function initWeek(){
      loadWeekForDate(state.today, {sync:true});
    }

    async function syncWeekFromApi(){
      if(!state.weekData){ return; }
      const ws = new Date(state.weekData.weekStart);
      const we = new Date(ws);
      we.setDate(we.getDate()+6);
      const startStr = fmtDate(ws);
      const endStr = fmtDate(we);
      await withGlobalLoading(async ()=>{
        try{
          const records = await apiFetchRange(startStr, endStr);
          const tasksByDate = new Map();
          records.forEach(rec=>{
            const rawDate = rec.date ?? rec.Date ?? rec['æ—¥æœŸ'] ?? rec['æ—¥æœŸ '] ?? rec['date'] ?? rec.timestamp ?? rec.Timestamp;
            const normalizedDate = normalizeApiDate(rawDate);
            if(!normalizedDate) return;
            const task = parseTaskFromApi(rec);
            if(!task) return;
            if(!tasksByDate.has(normalizedDate)){
              tasksByDate.set(normalizedDate, []);
            }
            tasksByDate.get(normalizedDate).push(task);
          });

          state.weekData.days.forEach(day=>{
            if(!day) return;
            ensureDayStructure(day);
            const existingMap = new Map();
            day.tasks.forEach(t=>{ existingMap.set(String(t.id), t); });
            const incoming = tasksByDate.get(day.date) || [];
            if(incoming.length){
              incoming.forEach(task=>{
                const prev = existingMap.get(String(task.id));
                if(prev && !task._hasRemoteDone){ task.done = !!prev.done; }
                ensureTaskReward(task);
                markTaskSource(task, 'api');
                delete task._hasRemoteDone;
              });
              day.tasks = incoming;
            }else{
              // ç§»é™¤èˆŠçš„ API ä»»å‹™ï¼Œä¿ç•™å…¶ä»–ä¾†æºçš„å…§å®¹
              day.tasks = day.tasks.filter(t=>t.source !== 'api');
              if(!day.tasks.length){
                day.tasks = defaultTasks();
              }
            }
            refreshDayStatus(day, {silent:true});
          });
          saveJSON(state.weekKey, state.weekData);
          state.currentWeekStart = state.weekData.weekStart;
          ensureSelectedDay();
          render();
          toastMsg('å·²å¾é›²ç«¯è¼‰å…¥æœ¬é€±ä»»å‹™ã€‚', 'success');
        }catch(err){
          console.error(err);
          toastMsg('é›²ç«¯è³‡æ–™è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨æœ¬åœ°è³‡æ–™ã€‚', 'warning');
        }
      });
    }

    function dayIndexByDate(dateStr){
      return state.weekData.days.findIndex(d=>d.date===dateStr);
    }

    function getDayByDate(dateStr){
      if(!state.weekData || !Array.isArray(state.weekData.days)){
        return {day:null, index:-1};
      }
      const idx = dayIndexByDate(dateStr);
      if(idx < 0){
        return {day:null, index:-1};
      }
      return {day: state.weekData.days[idx], index: idx};
    }

    async function fetchTasksForDate(dateStr){
      const records = await apiFetchRange(dateStr, dateStr);
      const tasks = [];
      records.forEach(rec=>{
        const task = parseTaskFromApi(rec);
        if(!task) return;
        ensureTaskReward(task);
        markTaskSource(task, 'api');
        tasks.push(task);
      });
      return tasks;
    }

    async function refreshDayFromApi(dateStr){
      const {day} = getDayByDate(dateStr);
      if(!day){ return; }
      const tasks = await fetchTasksForDate(dateStr);
      day.tasks = tasks;
      refreshDayStatus(day, {silent:true});
      saveJSON(state.weekKey, state.weekData);
    }

    function ensureSelectedDay(){
      if(!state.weekData || !Array.isArray(state.weekData.days)){
        return {day:null, index:-1};
      }
      let date = state.selectedDate;
      let idx = typeof date === 'string' ? dayIndexByDate(date) : -1;
      if(idx === -1){
        idx = dayIndexByDate(state.today);
      }
      if(idx === -1 && state.weekData.days.length){
        idx = 0;
      }
      if(idx >= 0){
        const day = state.weekData.days[idx];
        state.selectedDate = day.date;
        return {day, index: idx};
      }
      state.selectedDate = null;
      return {day:null, index:-1};
    }

    async function selectDay(dateStr){
      state.selectedDate = dateStr;
      state.loadingDate = dateStr;
      state.isLoadingDay = true;
      render();
      try{
        await withGlobalLoading(()=>refreshDayFromApi(dateStr));
      }catch(err){
        console.error(err);
        toastMsg('è®€å–ä»»å‹™å¤±æ•—ï¼Œå°‡é¡¯ç¤ºç›®å‰è³‡æ–™ã€‚', 'warning');
      }finally{
        const isCurrentRequest = state.loadingDate === dateStr;
        if(isCurrentRequest){
          state.isLoadingDay = false;
          state.loadingDate = null;
        }
        render();
      }
    }

    function render(){
      if(!state.weekData || !Array.isArray(state.weekData.days)){
        return;
      }
      const weekInfo = document.getElementById('weekInfo');
      if(weekInfo){
        const wsStr = state.weekData.weekStart;
        if(wsStr){
          const ws = new Date(wsStr);
          if(!Number.isNaN(ws.getTime())){
            const we = new Date(ws);
            we.setDate(we.getDate()+6);
            weekInfo.textContent = `æœ¬é€±ï¼š${fmtDate(ws)} ~ ${fmtDate(we)}`;
          }else{
            weekInfo.textContent = '';
          }
        }else{
          weekInfo.textContent = '';
        }
      }
      const weekPicker = document.getElementById('weekPicker');
      if(weekPicker){
        const pickerValue = state.selectedDate || state.weekData.days[0]?.date || '';
        weekPicker.value = pickerValue || '';
      }
      const mapRow = document.getElementById('mapRow');
      mapRow.innerHTML = '';
      const stickerRow = document.getElementById('stickerRow');
      stickerRow.innerHTML = '';

      const todayStr = state.today;
      const todayIdx = dayIndexByDate(todayStr);
      const {index: selectedIdx} = ensureSelectedDay();
      const selectedDate = selectedIdx >= 0 && state.weekData && state.weekData.days[selectedIdx]
        ? state.weekData.days[selectedIdx].date
        : null;

      state.weekData.days.forEach((d, i)=>{
        const status = refreshDayStatus(d, {silent:true});
        const isToday = i===todayIdx;
        const isDone = !!status.completed;
        const isSelected = selectedDate && d.date === selectedDate;
        const col = document.createElement('div');
        const cp = document.createElement('div');
        cp.className = 'checkpoint d-flex flex-column text-center mx-auto ' +
          (isToday? 'today ':'') + (isDone? 'done ':'') + (isSelected? 'selected ':'');
        cp.innerHTML = `<div class="day">${WEEK_DAYS[i]}</div><div class="cat">${isDone ? 'ğŸ…' : 'ğŸ¾'}</div>`;
        cp.setAttribute('role', 'button');
        cp.tabIndex = 0;
        cp.dataset.date = d.date;
        cp.addEventListener('click', ()=>selectDay(d.date));
        cp.addEventListener('keydown', (evt)=>{
          if(evt.key==='Enter' || evt.key===' ' || evt.key==='Spacebar' || evt.key==='Space'){
            evt.preventDefault();
            selectDay(d.date);
          }
        });
        col.appendChild(cp);
        mapRow.appendChild(col);

        const sCol = document.createElement('div'); sCol.className='col-4 col-sm-3 col-md-2';
        const sticker = document.createElement('div');
        const hasSticker = isStickerFilled(d.sticker);
        sticker.className = 'sticker ' + (hasSticker? 'filled':'');
        sticker.title = hasSticker ? `${d.date}ï½œ${getStickerTitle(d.sticker)}` : d.date;
        sticker.innerHTML = '';
        sticker.appendChild(createStickerContent(hasSticker ? d.sticker : null));
        sCol.appendChild(sticker); stickerRow.appendChild(sCol);
      });

      const info = document.getElementById('todayInfo');
      if(info){
        if(selectedDate){
          const parts = selectedDate.split('-').map(Number);
          const isPartsValid = parts.length===3 && parts.every(num=>Number.isFinite(num));
          const viewDate = isPartsValid ? new Date(parts[0], parts[1]-1, parts[2]) : new Date(selectedDate);
          const weekNames = ['æ—¥','ä¸€','äºŒ','ä¸‰','å››','äº”','å…­'];
          const isValid = isPartsValid ? true : !Number.isNaN(viewDate.getTime());
          const weekLabel = isValid ? weekNames[viewDate.getDay()] : '';
          const prefix = selectedDate === state.today ? 'ä»Šå¤©ä»»å‹™' : 'ç›®å‰é¡¯ç¤º';
          if(isValid){
            info.textContent = `${prefix}ï¼š${fmtDate(viewDate)}ï¼ˆé€±${weekLabel}ï¼‰`;
          }else{
            info.textContent = `${prefix}ï¼š${selectedDate}`;
          }
          info.textContent += 'ï½œé»æ“Šåœ°åœ–æˆ–ä½¿ç”¨å³å´æ—¥æœŸé¸æ“‡å™¨å¯åˆ‡æ›ã€‚';
        }else{
          info.textContent = 'å°šç„¡ä»»å‹™è³‡æ–™ã€‚';
        }
      }

      renderTodayTasks();
    }

    function renderTodayTasks(){
      const container = document.getElementById('taskList');
      container.innerHTML = '';
      const {day, index} = ensureSelectedDay();
      if(!day){
        updateRewardSummary();
        return;
      }
      if(state.isLoadingDay && state.loadingDate === day.date){
        container.innerHTML = '<div class="text-muted">æ­£åœ¨è¼‰å…¥ä»»å‹™â€¦</div>';
        const counter = document.getElementById('taskCounter');
        if(counter){ counter.textContent = 'ä»»å‹™è¼‰å…¥ä¸­â€¦'; }
        updateRewardSummary();
        return;
      }
      ensureDayStructure(day);
      const status = refreshDayStatus(day, {silent:true});
      const totalCount = status.total;
      const doneCount = status.doneCount;
      if(!day.tasks.length){
        container.innerHTML = '<div class="text-muted">ç›®å‰æ²’æœ‰ä»»å‹™ã€‚</div>';
      }
      day.tasks.forEach(task=>{
        ensureTaskReward(task);
        const wrapper = document.createElement('div');
        wrapper.className = 'task-check form-check d-flex align-items-start justify-content-between gap-3 mb-2 flex-wrap';

        const left = document.createElement('div');
        left.className = 'd-flex align-items-center flex-grow-1';

        const checkbox = document.createElement('input');
        checkbox.className = 'form-check-input me-2';
        checkbox.type = 'checkbox';
        checkbox.id = `task-${task.id}`;
        checkbox.dataset.taskId = task.id;
        checkbox.checked = !!task.done;

        const label = document.createElement('label');
        label.className = 'form-check-label flex-grow-1';
        label.setAttribute('for', checkbox.id);
        label.textContent = task.detail ? `${task.category} - ${task.detail}` : task.category;

        left.appendChild(checkbox);
        left.appendChild(label);

        const right = document.createElement('div');
        right.className = 'd-flex flex-column align-items-end gap-1';

        const rewardBadge = document.createElement('span');
        rewardBadge.className = 'badge text-bg-warning text-dark';
        rewardBadge.textContent = `ğŸ ${getTaskRewardLabel(task)}`;
        rewardBadge.title = 'å®Œæˆæ­¤ä»»å‹™å¯ç²å¾—çš„çå‹µ';

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-sm btn-outline-danger';
        removeBtn.type = 'button';
        removeBtn.dataset.removeTaskId = task.id;
        removeBtn.textContent = 'åˆªé™¤';

        right.appendChild(rewardBadge);
        right.appendChild(removeBtn);

        wrapper.appendChild(left);
        wrapper.appendChild(right);
        container.appendChild(wrapper);
      });

      const counter = document.getElementById('taskCounter');
      if(counter){
        const isToday = index >= 0 && state.weekData.days[index].date === state.today;
        const completionMsg = status.completed
          ? (isToday ? 'ä»Šæ—¥ä»»å‹™å·²å®Œæˆï¼Œå·²è‡ªå‹•è“‹ç« ï¼' : 'æ­¤æ—¥ä»»å‹™å·²å®Œæˆã€‚')
          : 'å®Œæˆä»»å‹™å¾Œæœƒè‡ªå‹•è“‹ç« ä¸¦æ”¶é›†è²¼ç´™ã€‚';
        const counterMsg = totalCount
          ? `å·²å®Œæˆ ${doneCount} / ${totalCount} é …ä»»å‹™ã€‚${completionMsg}`
          : 'ç›®å‰æ²’æœ‰ä»»å‹™ã€‚';
        counter.textContent = counterMsg;
      }

      updateRewardSummary();
    }

    async function toggleTask(taskId, value){
      const {day} = ensureSelectedDay();
      if(!day) return;
      const task = day.tasks.find(t=>String(t.id)===String(taskId));
      if(!task) return;
      const desired = !!value;
      if(task.source === 'api'){
        try{
          await withGlobalLoading(()=>apiUpdateRecord(String(task.id), {done: desired}));
          task.done = desired;
          refreshDayStatus(day, {silent:false});
          saveJSON(state.weekKey, state.weekData);
          render();
        }catch(err){
          console.error(err);
          toastMsg(`åŒæ­¥ä»»å‹™ç‹€æ…‹å¤±æ•—ï¼š${err.message}`, 'warning');
          render();
          throw err;
        }
      }else{
        task.done = desired;
        refreshDayStatus(day, {silent:false});
        saveJSON(state.weekKey, state.weekData);
        render();
      }
    }

    async function addTask(category, detail, reward){
      const {day} = ensureSelectedDay();
      if(!day) return;
      ensureDayStructure(day);
      const trimmedDetail = detail.trim();
      const taskId = generateApiId();
      const task = markTaskSource({ id: taskId, category, detail: trimmedDetail, done: false, reward: reward || defaultReward() }, 'api');
      ensureTaskReward(task);
      const payload = encodeTaskForApi(task, day.date);
      try{
        await withGlobalLoading(()=>apiAddRecord(payload));
        day.tasks = day.tasks.filter(t=>!(t.source === 'api' && String(t.id) === String(taskId)));
        day.tasks.push(task);
        refreshDayStatus(day, {silent:true});
        saveJSON(state.weekKey, state.weekData);
        render();
        toastMsg('å·²æ–°å¢ä»»å‹™ä¸¦åŒæ­¥é›²ç«¯ã€‚', 'success');
      }catch(err){
        console.error(err);
        toastMsg(`æ–°å¢ä»»å‹™å¤±æ•—ï¼š${err.message}`, 'warning');
        throw err;
      }
    }

    async function removeTask(taskId){
      const {day} = ensureSelectedDay();
      if(!day) return;
      const before = day.tasks.length;
      const task = day.tasks.find(t=>String(t.id)===String(taskId));
      if(!task){ return; }
      if(task.source === 'api'){
        try{
          await withGlobalLoading(()=>apiDeleteRecord(String(taskId)));
        }catch(err){
          console.error(err);
          toastMsg(`åˆªé™¤ä»»å‹™å¤±æ•—ï¼š${err.message}`, 'warning');
          throw err;
        }
      }
      day.tasks = day.tasks.filter(t=>String(t.id)!==String(taskId));
      if(day.tasks.length !== before){
        refreshDayStatus(day, {silent:true});
        saveJSON(state.weekKey, state.weekData);
        render();
        toastMsg('å·²åˆªé™¤ä»»å‹™ã€‚', 'info');
      }
    }

    function toastMsg(text, type='info'){
      const msg = document.getElementById('msg');
      const cls = type==='success'? 'alert-success' : (type==='info'? 'alert-secondary' : 'alert-warning');
      msg.innerHTML = `<div class="alert ${cls} py-2 px-3 mb-0">${text}</div>`;
      setTimeout(()=>{ msg.innerHTML=''; }, 2800);
    }

    const API_URL = 'https://script.google.com/macros/s/AKfycby30UjHuZoxAxr-l6-HbJd8H0K3YTNEEfnRyrm9yOj5egBKJXBgMpEtKYxhVem6uA6t/exec';

    async function apiFetchRange(start, end){
      const url = `${API_URL}?mode=range&startDate=${encodeURIComponent(start)}&endDate=${encodeURIComponent(end)}`;
      const resp = await fetch(url);
      if(!resp.ok){
        throw new Error(`API è«‹æ±‚å¤±æ•— (${resp.status})`);
      }
      const data = await resp.json();
      if(!data.success){
        throw new Error(data.message || 'API æŸ¥è©¢å¤±æ•—');
      }
      return Array.isArray(data.data) ? data.data : [];
    }

    async function apiAddRecord({id, date, item, reward, done}){
      const body = new URLSearchParams();
      body.append('action', 'add');
      body.append('id', id);
      body.append('date', date);
      body.append('item', item);
      body.append('reward', reward);
      const doneValue = typeof done === 'string' ? done : formatDoneFlag(!!done);
      body.append('done', doneValue);
      body.append('å®Œæˆ ', doneValue);
      body.append('å®Œæˆ', doneValue);

      const resp = await fetch(API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
        },
        body: body.toString()
      });
      if(!resp.ok){
        throw new Error(`API è«‹æ±‚å¤±æ•— (${resp.status})`);
      }
      const data = await resp.json();
      if(!data.success){
        throw new Error(data.message || 'æ–°å¢å¤±æ•—');
      }
      return data;
    }

    async function apiUpdateRecord(id, updates={}){
      const body = new URLSearchParams();
      body.append('action', 'update');
      body.append('id', id);

      if(Object.prototype.hasOwnProperty.call(updates, 'date') && updates.date !== undefined && updates.date !== null){
        body.append('date', updates.date);
      }
      if(Object.prototype.hasOwnProperty.call(updates, 'item') && updates.item !== undefined && updates.item !== null){
        body.append('item', updates.item);
      }
      if(Object.prototype.hasOwnProperty.call(updates, 'reward') && updates.reward !== undefined && updates.reward !== null){
        body.append('reward', updates.reward);
      }
      if(Object.prototype.hasOwnProperty.call(updates, 'done')){
        const doneValue = typeof updates.done === 'string' ? updates.done : formatDoneFlag(!!updates.done);
        body.append('done', doneValue);
        body.append('å®Œæˆ ', doneValue);
        body.append('å®Œæˆ', doneValue);
      }

      const resp = await fetch(API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
        },
        body: body.toString()
      });
      if(!resp.ok){
        throw new Error(`API è«‹æ±‚å¤±æ•— (${resp.status})`);
      }
      const data = await resp.json();
      if(!data.success){
        throw new Error(data.message || 'æ›´æ–°å¤±æ•—');
      }
      return data;
    }

    async function apiDeleteRecord(id){
      const body = new URLSearchParams();
      body.append('action', 'delete');
      body.append('id', id);

      const resp = await fetch(API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
        },
        body: body.toString()
      });
      if(!resp.ok){
        throw new Error(`API è«‹æ±‚å¤±æ•— (${resp.status})`);
      }
      const data = await resp.json();
      if(!data.success){
        throw new Error(data.message || 'åˆªé™¤å¤±æ•—');
      }
      return data;
    }

    // === ç¶å®š ===
    window.addEventListener('DOMContentLoaded', async ()=>{
      ensureCatSpriteStyles();
      initWeek();
      const weekPickerInput = document.getElementById('weekPicker');
      if(weekPickerInput){
        weekPickerInput.addEventListener('change', (e)=>{
          const normalized = normalizeApiDate(e.target.value || '');
          if(!normalized){
            return;
          }
          const selectedWeekStart = fmtDate(weekStart(new Date(normalized)));
          const currentWeekStart = state.currentWeekStart || (state.weekData ? state.weekData.weekStart : null);
          if(currentWeekStart === selectedWeekStart){
            selectDay(normalized);
          }else{
            loadWeekForDate(normalized, {sync:true});
          }
        });
      }
      document.getElementById('taskList').addEventListener('change', (e)=>{
        if(e.target.matches('input[type="checkbox"][data-task-id]')){
          const checkbox = e.target;
          const taskId = checkbox.dataset.taskId;
          const isChecked = checkbox.checked;
          checkbox.disabled = true;
          toggleTask(taskId, isChecked)
            .catch(()=>{
              checkbox.checked = !isChecked;
            })
            .finally(()=>{
              checkbox.disabled = false;
            });
        }
      });
      document.getElementById('taskList').addEventListener('click', (e)=>{
        if(e.target.dataset.removeTaskId){
          const btn = e.target;
          btn.disabled = true;
          removeTask(e.target.dataset.removeTaskId)
            .catch(()=>{})
            .finally(()=>{ btn.disabled = false; });
        }
      });
      const addTaskButton = document.getElementById('btnAddTask');
      addTaskButton.addEventListener('click', async ()=>{
        const category = document.getElementById('taskCategory').value;
        const detailInput = document.getElementById('taskDetail');
        const detail = detailInput.value;
        const rewardTypeSelectEl = document.getElementById('rewardType');
        const rewardType = rewardTypeSelectEl.value;
        const rewardPoints = document.getElementById('rewardPoints');
        const rewardCustom = document.getElementById('rewardCustom');
        if(!category && !detail.trim()) return;
        let reward;
        if(rewardType === 'custom'){
          reward = {type:'custom', value:(rewardCustom.value || '').trim()};
        }else if(rewardType === 'points'){
          const num = Number(rewardPoints.value);
          const safe = Number.isFinite(num) ? Math.max(0, Math.round(num)) : 0;
          reward = {type:'points', value:safe};
        }else if(rewardType.startsWith('preset:')){
          const presetText = rewardType.slice('preset:'.length) || rewardTypeSelectEl.options[rewardTypeSelectEl.selectedIndex]?.text || '';
          reward = {type:'custom', value:presetText};
        }else{
          reward = {type:'custom', value:(rewardCustom.value || '').trim()};
        }
        addTaskButton.disabled = true;
        try{
          await addTask(category || 'å…¶ä»–', detail, reward);
          detailInput.value = '';
          detailInput.focus();
          if(rewardType === 'custom'){
            rewardCustom.value = '';
          }
        }catch(err){
          // è‹¥å¤±æ•—å‰‡ä¿æŒè¼¸å…¥å…§å®¹ä¾›ä½¿ç”¨è€…èª¿æ•´
        }finally{
          addTaskButton.disabled = false;
        }
      });
      document.getElementById('taskDetail').addEventListener('keydown', (e)=>{
        if(e.key==='Enter'){
          e.preventDefault();
          document.getElementById('btnAddTask').click();
        }
      });
      const rewardTypeSelect = document.getElementById('rewardType');
      const rewardPointsInput = document.getElementById('rewardPoints');
      const rewardCustomInput = document.getElementById('rewardCustom');
      function syncRewardInputs(){
        const type = rewardTypeSelect.value;
        const isCustom = type === 'custom';
        const isPoints = type === 'points';
        rewardPointsInput.classList.toggle('d-none', !isPoints);
        rewardPointsInput.disabled = !isPoints;
        rewardCustomInput.classList.toggle('d-none', !isCustom);
        rewardCustomInput.disabled = !isCustom;
        if(isCustom){
          rewardCustomInput.focus();
        }else if(isPoints){
          rewardPointsInput.focus();
        }
      }
      rewardTypeSelect.addEventListener('change', syncRewardInputs);
      syncRewardInputs();

    });
  </script>
</body>
</html>
